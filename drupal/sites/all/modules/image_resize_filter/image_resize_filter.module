<?php
// $Id: image_resize_filter.module,v 1.47 2010/05/16 21:40:34 quicksketch Exp $

/**
 * @file image_resize_filter.module
 *
 * After adding to a text format, this filter will parse the contents of
 * submitted content and automatically scale image files to match the set
 * dimensions of img tags.
 *
 * Image that have been created take on the ownership of the original file.
 * Making so when the primary node is deleted, the images it provided are
 * deleted also.
 *
 */

/**
 * Implements hook_help().
 */
function image_resize_filter_help($path, $arg) {
  switch ($path) {
    case 'admin/help#image_resize_filter':
      $instructions = array(
        t('Visit the <a href="!url">Text formats</a> configuration page. Click "configure" next to the text format you want to enable the image resize filter on.', array('!url' => 'admin/config/content/formats')),
        t('Check the box for "Image resize filter" under the list of filters.'),
        t('<strong>Important</strong>: Re-order your enabled filters under "Filter processing order".') .
        '<p>' . t('If using the Image Resize Filter on the "Filtered HTML" text format, you <strong>must</strong> ensure A) that the &lt;img&gt; tag is in the list of allowed tags and B) The "Image resize filter" is run <strong>before</strong> the "HTML filter".') . '</p>' .
        '<p>' . t('If using the Image Resize Filter with BBCode or some other non-HTML filter, the "Image resize filter" must be run AFTER the BBCode filter.') . '</p>',
        t('Optional. Click the Image resize filter tab underneath "Filter settings" to set additional configuration for the the image resize filter.'),
      );

      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The image resize filter module provides a <a href="!url">filter</a> that makes it easy to resize images, especially when combined with a WYSIWYG editor such as tinyMCE or FCKeditor. Users never have to worry about scaling image sizes again, just insert an image and set it\'s height and width properties in HTML and the image is resized on output. To use the image resize filter, follow these steps.', array('!url' => url('admin/help/filter'))) . '</p>';
      $output .= theme('item_list', array('items' => $instructions, 'type' => 'ol', 'title' => t('Installation and use')));
      return $output;
  }
}

/**
 * Implements hook_filter_info().
 */
function image_resize_filter_filter_info() {
  $filters = array();
  $filters['image_resize_filter'] = array(
    'title' => t('Image resize filter'),
    'process callback' => 'image_resize_filter_process_filter',
    'settings callback' => 'image_resize_filter_form',
    'default settings' => array(
      'link' => 0,
      'link_class' => '',
      'link_rel' => '',
      'image_locations' => array('local'),
    ),
    'weight' => 0,
  );
  return $filters;
}

/**
 * Filter callback function.
 */
function image_resize_filter_process_filter($text, $filter) {
  $settings['link'] = $filter->settings['link'];
  $settings['class'] = $filter->settings['link_class'];
  $settings['rel'] = $filter->settings['link_rel'];
  $settings['image_locations'] = array_filter($filter->settings['image_locations']);
  $images = image_resize_filter_get_images($settings, $text);
  return image_resize_filter_process_images($images, $text, $settings);
}

/**
 * Implements hook_file_delete().
 */
function image_resize_filter_file_delete($file) {
  if (isset($file->uri)) {
    image_resize_filter_delete_derivatives($file->uri);
  }
}

/**
 * Implements hook_theme().
 */
function image_resize_filter_theme() {
  return array(
    'image_resize_filter_form' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_file_download().
 */
function image_resize_filter_file_download($uri) {
  // If this is a resized image, use the same access as the original image.
  $matches = array();
  if (preg_match('/^resize\/(.*)?-\d+x\d+(\.png|\.jpg|\.jpeg|\.gif)$/i', $uri, $matches)) {
    $headers = module_invoke_all('file_download', $matches[1] . $matches[2]);
    if (in_array(-1, $headers)) {
      return -1;
    }
    if (count($headers)) {
      return array(
        'Content-Type: ' . file_get_mimetype($uri),
        'Content-Length: ' . filesize($uri),
      );
    }
  }
}

/**
 * Implements hook_form_[form_id]_alter().
 */
function image_resize_filter_form_system_file_system_settings_alter($form, $form_state) {
  $form['#submit'][] = 'image_resize_filter_file_system_settings_submit';
}

/**
 * Additional #submit handler for the system_file_system_settings form.
 */
function image_resize_filter_file_system_settings_submit($form, $form_state) {
  // Clear filter caches when changing file system information.
  cache_clear_all('*', 'cache_filter');
}

/**
 * The form for configuring the Image Resize Filter.
 */
function image_resize_filter_form($form, &$form_state, $filter, $format, $defaults) {
  $filter->settings += $defaults;

  $settings['image_resize'] = array(
    '#description' => t('The image resize filter will analyze &lt;img&gt; tags and compare the given height and width attributes to the actual file. If the file dimensions are different than those given in the &lt;img&gt; tag, the image will be copied and the src attribute will be updated to point to the resized image.'),
    '#theme' => 'image_resize_filter_form',
    '#format' => $format,
    '#parents' => array('filters', 'image_resize_filter', 'settings'),
  );

  $settings['image_resize']['image_locations'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Resize images stored'),
    '#options' => array('local' => t('Locally'), 'remote' => t('On remote servers (note: this copies <em>all</em> remote images locally)')),
    '#default_value' => $filter->settings['image_locations'],
    '#description' => t('This option will determine which images will be analyzed for &lt;img&gt; tag differences. Enabling resizing of remote images can have performance impacts, as all images in the filtered text needs to be transfered via HTTP each time the filter cache is cleared.'),
  );

  $settings['image_resize']['link'] = array(
    '#type' => 'checkbox',
    '#title' => t('If resized, add a link to the original image.'),
    '#default_value' => $filter->settings['link'],
  );

  $settings['image_resize']['link_class'] = array(
    '#type' => 'textfield',
    '#title' => t('Optionally, give it the class'),
    '#size' => '10',
    '#default_value' => $filter->settings['link_class'],
  );

  $settings['image_resize']['link_rel'] = array(
    '#type' => 'textfield',
    '#title' => t('and/or a rel attribute'),
    '#size' => '10',
    '#default_value' => $filter->settings['link_rel'],
  );

  return $settings;
}

/**
 * Theme callback to theme the Image Resize Filter form.
 */
function theme_image_resize_filter_form($variables) {
  $form = $variables['form'];
  $format = $form['#format'];

  $link = 'link';
  $class = 'link_class';
  $rel = 'link_rel';

  $class_element = ' ';
  $class_element .= '<span class="image-resize-filter-class">';
  $class_element .= check_plain($form[$class]['#title']) .': ';
  $form[$class]['#title'] = NULL;
  $class_element .= drupal_render($form[$class]);
  $class_element .= '</span>';

  $rel_element = ' ';
  $rel_element .= '<span class="image-resize-filter-rel">';
  $rel_element .= check_plain($form[$rel]['#title']) .': ';
  $form[$rel]['#title'] = NULL;
  $rel_element .= drupal_render($form[$rel]);
  $rel_element .= '</span>';

  $link_element = drupal_render($form[$link]);

  $output = '';
  $output .= '<div class="container-inline image-resize-filter-link-options">';
  $output .= $link_element;
  $output .= $class_element;
  $output .= $rel_element;
  $output .= '</div>';

  $form['placeholder'] = array(
    '#type' => 'element',
    '#title' => t('Link to the original'),
    '#title_display' => 'before',
    '#children' => $output,
    '#description' => t('Linking to the original can be helpful to give users a full-size view of the image. Adding the class "thickbox" is helpful if you have installed the <a href="http://drupal.org/project/thickbox">thickbox module</a>. The rel attribute may be useful when used with the <a href="http://drupal.org/project/lightbox2">lightbox2</a> and <a href="http://drupal.org/project/shadowbox">shadowbox</a> modules.'),
  );

  // Add a little bit of JavaScript. Not cached since it's only used here.
  drupal_add_js(drupal_get_path('module', 'image_resize_filter') . '/image_resize_filter.js', array('aggregate' => FALSE));
  return filter_xss_admin($form['#description']) . drupal_render_children($form);
}

/**
 * Parsing function to locate all images in a piece of text that need replacing.
 *
 * @param $settings
 *   An array of settings that will be used to identify which images need
 *   updating. Includes the following:
 *
 *   - image_locations: An array of acceptable image locations. May contain any
 *     of the following values: "remote". Remote image will be downloaded and
 *     saved locally. This procedure is intensive as the images need to
 *     be retrieved to have their dimensions checked.
 *
 * @param $text
 *   The text to be updated with the new img src tags.
 */
function image_resize_filter_get_images($settings, $text) {
  $images = array();

  // Find all image tags, ensuring that they have a src.
  $matches = array();
  preg_match_all('/((<a [^>]*>)[ ]*)?(<img[^>]*?src[ ]*=[ ]*"([^"]+)"[^>]*>)/i', $text, $matches);

  // Loop through matches and find if replacements are necessary.
  // $matches[0]: All complete image tags and preceeding anchors.
  // $matches[1]: The anchor tag of each match (if any).
  // $matches[2]: The anchor tag and trailing whitespace of each match (if any).
  // $matches[3]: The complete img tag.
  // $matches[4]: The src value of each match.
  foreach ($matches[0] as $key => $match) {
    $has_link = (bool) $matches[1][$key];
    $img_tag = $matches[3][$key];
    $src = $matches[4][$key];

    $resize = NULL;
    $width = NULL;
    $height = NULL;
    $needs_width = TRUE;
    $needs_height = TRUE;

    // Because we don't know the order of the attributes and images might not
    // have both attributes, match individually for height and width.
    foreach (array('width', 'height') as $property) {
      $property_matches = array();
      preg_match_all('/[ \'";]' . $property . '[ ]*([=:])[ ]*"?([0-9]+)(%?)"?/i', $img_tag, $property_matches);

      // If this image uses percentage width or height, do not process it.
      if (in_array('%', $property_matches[3])) {
        $resize = FALSE;
        $needs_width = FALSE;
        $needs_height = FALSE;
        break;
      }

      // In the odd scenario there is both a style="width: xx" and a width="xx"
      // tag, base our calculations off the style tag, since that's what the
      // browser will display.
      $property_key = 0;
      $property_count = count($property_matches[1]);
      $needs_property = TRUE;
      if ($property_count) {
        $property_key = array_search(':', $property_matches[1]);
        $needs_property = FALSE;
      }
      // Only a style property found, we'll need to add a real height/width tag
      // to the HTML later. This specifically prevents problems with FCKeditor
      // that only adds style tags when resizing images.
      if ($property_count == 1 && strcmp($property_matches[1][$property_key], ':') == 0){
        $needs_property = TRUE;
      }
      ${$property} = !empty($property_matches[2][$property_key]) ? $property_matches[2][$property_key] : FALSE;
      ${'needs_' . $property} = $needs_property;
    }

    // Find the image title if any.
    $title = NULL;
    $title_matches = array();
    preg_match('/title[ ]*=[ ]*"([^"]+)"/i', $img_tag, $title_matches);
    if (isset($title_matches[1])) {
      $title = $title_matches[1];
    }

    // Determine if this is a local or remote file.
    $location = 'unknown';
    if (strpos($src, '/') === 0 || strpos($src, '.') === 0) {
      $location = 'local';
    }
    elseif (preg_match('/http[s]?:\/\/' . preg_quote($_SERVER['HTTP_HOST'], '/') . '/', $src)) {
      $location = 'local';
    }
    elseif (strpos($src, 'http') === 0) {
      $location = 'remote';
    }

    // If not resizing images in this location, continue on to the next image.
    if (!in_array($location, $settings['image_locations'])) {
      continue;
    }

    // Convert the URL to a local path.
    $local_path = NULL;
    if ($location == 'local') {
      if (strpos($src, '.') !== 0) {
        // Remove the http:// and base path.
        $local_path = preg_replace('/(http[s]?:\/\/' . preg_quote($_SERVER['HTTP_HOST'], '/') . ')?' . preg_quote(base_path(), '/') . '/', '', $src, 1);

        // Build a list of acceptable language prefixes.
        $lang_codes = '';
        if (array_key_exists('locale-url', variable_get('language_negotiation_language', array())) && variable_get('locale_language_negotiation_url_part', 0) == 0) {
          $languages = language_list();
          $lang_codes = array();
          foreach ($languages as $key => $language) {
            if ($language->prefix) {
              $lang_codes[$key] = preg_quote($language->prefix, '!');
            }
          }
          $lang_codes = $lang_codes ? '((' . implode('|', $lang_codes) . ')/)?' : '';
        }

        // Convert to a file system path if using private files.
        if (preg_match('!^(\?q\=)?' . $lang_codes . 'system/files/!', $local_path)) {
          $local_path = file_directory_path('private') . '/' . preg_replace('!^(\?q\=)?' . $lang_codes . 'system/files/!', '', $local_path);
        }
      }
      $local_path = rawurldecode($local_path);
    }

    // If this is an ImageCache preset, generate the source image if necessary.
    if ($location == 'local' && !file_exists($local_path) && strpos($local_path, 'styles/') !== FALSE && function_exists('image_style_url')) {
      $imagecache_path = preg_replace('/^' . preg_quote(file_directory_path(), '/') . '\/imagecache\//', '', $local_path);
      $imagecache_args = explode('/', $imagecache_path);
      $preset_name = array_shift($imagecache_args);
      $original_path = implode('/', $imagecache_args);
      // ImageCache can resize images both inside and outside of the files
      // directory. If the image doesn't exist at the given path, check inside
      // the files directory.
      if (!file_exists($original_path)) {
        $original_path = file_directory_path() . '/' . $original_path;
      }
      if (file_exists($original_path) && $preset = imagecache_preset_by_name($preset_name)) {
        imagecache_build_derivative($preset['actions'], $original_path, imagecache_create_path($preset_name, $original_path));
      }
    }

    // If this is a remote image, retreive it to check its size.
    if ($location == 'remote') {
      $result = drupal_http_request($src);
      if ($result->code == 200) {
        $tmp_file = tempnam(file_directory_path('temp'), 'image_resize_filter_');
        $handle = fopen($tmp_file, 'w');
        fwrite($handle, $result->data);
        fclose($handle);
        $local_path = $tmp_file;
      }
    }

    // Get the image size.
    if (is_file($local_path)) {
      $image_size = @getimagesize($local_path);
    }

    // All this work and the image isn't even there. Bummer. Next image please.
    if (empty($image_size)) {
      image_resize_filter_delete_temp_file($location, $local_path);
      continue;
    }

    $actual_width = $image_size[0];
    $actual_height = $image_size[1];

    // If either height or width is missing, calculate the other.
    if (!$width && !$height) {
      $width = $actual_width;
      $height = $actual_height;
    }
    if (!$height) {
      $ratio = $actual_height/$actual_width;
      $height = round($ratio * $width);
    }
    elseif (!$width) {
      $ratio = $actual_width/$actual_height;
      $width = round($ratio * $height);
    }

    // Determine if this image requires a resize.
    if (!isset($resize)) {
      $resize = ($actual_width != $width || $actual_height != $height);
    }

    // Skip processing if these conditions are met:
    // - The image already has both height and width attributes.
    // - The image is local and is already the right size.
    // - The image is remote and a 1x1 pixel tracking image.
    if ((!$needs_width && !$needs_height) &&
        (($location == 'local' && !$resize) ||
         ($location == 'remote' && $actual_width == 1 && $actual_height == 1))) {
      image_resize_filter_delete_temp_file($location, $local_path);
      continue;
    }

    // Check the image extension by name.
    $extension_matches = array();
    preg_match('/\.([a-zA-Z0-9]+)$/', $src, $extension_matches);
    if (!empty($extension_matches)) {
      $extension = strtolower($extension_matches[1]);
    }
    // If the name extension failed (such as an image generated by a script),
    // See if we can determine an extension by MIME type.
    elseif (isset($image_size['mime'])) {
      switch ($image_size['mime']) {
        case 'image/png':
          $extension = 'png';
          break;
        case 'image/gif':
          $extension = 'gif';
          break;
        case 'image/jpeg':
        case 'image/pjpeg':
          $extension = 'jpg';
          break;
      }
    }

    // If we're not certain we can resize this image, skip it.
    if (!isset($extension) || !in_array(strtolower($extension), array('png', 'jpg', 'jpeg', 'gif'))) {
      image_resize_filter_delete_temp_file($location, $local_path);
      continue;
    }

    // If getting this far, the image exists and is not the right size or needs
    // to be saved locally from a remote server.
    // Add all information to a list of images that need resizing.
    $images[] = array(
      'expected_size' => array('width' => $width, 'height' => $height),
      'actual_size' => array('width' => $image_size[0], 'height' => $image_size[1]),
      'add_properties' => array('width' => $needs_width, 'height' => $needs_height),
      'resize' => $resize,
      'img_tag' => $img_tag,
      'title' => $title,
      'has_link' => $has_link,
      'original' => $src,
      'location' => $location,
      'local_path' => $local_path,
      'mime' => $image_size['mime'],
      'extension' => $extension,
    );
  }

  return $images;
}


/**
 * Processing function for image resize filter. Replace img src properties
 * with a URL to a resized image.
 *
 * @param $images
 *   An array of image information, detailing images that need to be replaced.
 * @param $text
 *   The original text of the post that needs src tags updated.
 * @param $settings
 *   An array of setting for generating the image tag.
 */
function image_resize_filter_process_images($images, $text, $settings) {
  $local_file_path = '';
  foreach ($images as $image) {
    // Copy remote images locally.
    if ($image['location'] == 'remote') {;
      $local_file_path = 'resize/remote/' . md5(file_get_contents($image['local_path'])) . '-' . $image['expected_size']['width'] . 'x' . $image['expected_size']['height'] . '.'. $image['extension'];
      $image['destination'] = variable_get('file_default_scheme', 'public') . '://' . $local_file_path;
    }
    // Destination and local path are the same if we're just adding attributes.
    elseif (!$image['resize']) {
      $image['destination'] = $image['local_path'];
    }
    else {
      $path_info = image_resize_filter_pathinfo($image['local_path']);
      $local_file_dir = file_uri_target($path_info['dirname']);
      $local_file_path = 'resize/' . ($local_file_dir ? $local_file_dir . '/' : '') . $path_info['filename'] . '-' . $image['expected_size']['width'] . 'x' . $image['expected_size']['height'] . '.' . $path_info['extension'];
      $image['destination'] = $path_info['scheme'] . '://' . $local_file_path;
    }

    if (!file_exists($image['destination'])) {
      // Create the resize directory.
      $directory = dirname($image['destination']);
      file_prepare_directory($directory, FILE_CREATE_DIRECTORY);

      // Move remote images into place if they are already the right size.
      if ($image['location'] == 'remote' && !$image['resize']) {
        $handle = fopen($image['destination'], 'w');
        fwrite($handle, file_get_contents($image['local_path']));
        fclose($handle);
      }
      // Resize the local image if the sizes don't match.
      elseif ($image['resize']) {
        $res = image_load($image['local_path']);
        image_resize($res, $image['expected_size']['width'], $image['expected_size']['height']);
        image_save($res, $image['destination']);
      }
      @chmod($image['destination'], 0664);
    }

    // Delete our temporary file if this is a remote image.
    image_resize_filter_delete_temp_file($image['location'], $image['local_path']);

    // Replace the existing image source with the resized image.
    // Set the image we're currently updating in the callback function.
    image_resize_filter_update_tag(NULL, $image, $settings);
    $text = preg_replace_callback('/(<img[^>]*?src[ ]*=[ ]*")' . preg_quote($image['original'] ,'/') . '("[^>]*?)(\/?>)/i', 'image_resize_filter_update_tag', $text);
  }
  return $text;
}

/**
 * Regular expression callback.
 *
 * @param $matches
 *   The matches for a call to preg_replace_callback().
 * @param $new_image
 *   If passed in, this will set a static variable so that this image data is
 *   available when this function is called from a regular expression.
 */
function image_resize_filter_update_tag($matches = NULL, $new_image = NULL, $new_settings = NULL) {
  global $base_url;
  static $image, $settings;

  $image = isset($new_image) ? $new_image : $image;
  $settings = isset($new_settings) ? $new_settings : $settings;

  if (!isset($matches)) {
    return;
  }

  // Do not do replacements if the image tag doesn't match exactly. This can
  // happen if the same image is in the same post multiple times.
  if ($matches[0] != $image['img_tag']) {
    return $matches[0];
  }

  $src = file_create_url($image['destination']);

  // Strip the http:// from the path if the original did not include it.
  if (!preg_match('/^http[s]?:\/\/' . preg_quote($_SERVER['HTTP_HOST']) . '/', $image['original'])) {
    $src = preg_replace('/^http[s]?:\/\/' . preg_quote($_SERVER['HTTP_HOST']) . '/', '', $src);
  }

  $output = '';
  $output .= $matches[1]; // The start of the tag.
  $output .= $src; // The new src.
  $output .= $matches[2]; // The end of the tag, excluding the closing "/>".

  // Add height and width properties if they are missing from the original tag.
  $output .= $image['add_properties']['width'] ? ' width="' . $image['expected_size']['width'] . '"' : '';
  $output .= $image['add_properties']['height'] ? ' height="' . $image['expected_size']['height'] . '"' : '';

  $output .= $matches[3]; // The closing "/>".
  if ($image['resize'] && $settings['link'] && !$image['has_link']) {
    $class = !empty($settings['class']) ? ' class="' . $settings['class'] . '"' : '';
    $rel = !empty($settings['rel']) ? ' rel="' . $settings['rel'] . '"' : '';
    $title = !empty($image['title']) ? ' title="' . $image['title'] . '"' : '';
    $output = '<a href="' . $image['original'] . '"' . $title . $class . $rel . '>' . $output . '</a>';
  }

  return $output;
}

/**
 * A short-cut function to delete temporary remote images.
 */
function image_resize_filter_delete_temp_file($source, $uri) {
  if ($source == 'remote' && is_file($uri)) {
    @unlink($uri);
  }
}

/**
 * Delete all generated image when the original file is removed.
 */
function image_resize_filter_delete_derivatives($original_uri) {
  // First delete all derivatives in the saved file location.
  $path_info = image_resize_filter_pathinfo($original_uri);
  $basename = $path_info['filename'];
  $extension = $path_info['extension'];
  $directory = str_replace($path_info['scheme'] . '://', $path_info['scheme'] . '://resize/', $path_info['dirname']);

  // Delete all the derivatives.
  $files = file_scan_directory($directory, '/' . preg_quote($basename, '/') . '-[0-9]+[x][0-9]+\.' . preg_quote($extension, '/') . '/', array('callback' => 'file_unmanaged_delete'));

  // Then work up the directories and delete any empty ones.
  $folders = explode('/', $directory);
  $directories = array();
  $current_directory = '';
  foreach ($folders as $folder) {
    $current_directory .= $folder . '/';
    $directories[] = $current_directory;
  }

  foreach (array_reverse($directories) as $directory) {
    if ($directory == ($path_info['scheme'] . '://')) {
      break;
    }

    $directory_files = file_scan_directory($directory, '/.*/');
    if (empty($directory_files)) {
      @rmdir($directory);
    }
    else {
      break;
    }
  }
}

/**
 * Delete the entire set of cached images.
 */
function image_resize_filter_delete_all() {
  $directory = file_directory_path() . '/resize';
  image_resize_filter_delete_recursive($directory);
  cache_clear_all('*', 'cache_filter');
}

/**
 * Recursive deletion function for clearing out resized images directory.
 */
function image_resize_filter_delete_recursive($path) {
  if (is_file($path) || is_link($path)) {
    unlink($path);
  }
  elseif (is_dir($path)) {
    $dir = dir($path);
    while (($entry = $dir->read()) !== false) {
      if ($entry == '.' || $entry == '..') {
        continue;
      }
      $entry_path = $path . '/' . $entry;
      image_resize_filter_delete_recursive($entry_path);
    }
    rmdir($path);
  }
}

/**
 * Utility function to return path information.
 */
function image_resize_filter_pathinfo($uri) {
  $info = pathinfo($uri);
  $info['extension'] = substr($uri, strrpos($uri, '.') + 1);
  $info['basename'] = basename($uri);
  $info['filename'] = basename($uri, '.' . $info['extension']);
  $info['scheme'] = file_uri_scheme($uri);

  if (empty($info['scheme'])) {
    foreach (file_get_stream_wrappers() as $scheme => $stream_wrapper) {
      $matches = array();
      if (preg_match('/^' . preg_quote(file_directory_path($scheme), '/') . '\/?(.*)/', $info['dirname'], $matches)) {
        $info['scheme'] = $scheme;
        $info['dirname'] = $scheme . '://' . $matches[1];
        break;
      }
    }
  }

  return $info;
}
